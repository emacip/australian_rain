---
title: "Rain in Australia"
author: "Adrian Romero Hernandez, Enrique Macip Belmonte, Maria Ruiz Teixidor"
date: "19 de diciembre de 2019"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      section_divs: true
    theme: "sandstone"
    highlight: "zenburn"
    code_folding: "hide"
---

## Introducción y definición de objetivos 

Link repositorio en [Github Australian Rain](https://github.com/emacip/australian_rain)


Los datos obtenidos de Kaggle tienen la información atmosférica de varios años en Australia, datos en los que viene incluida desde la velocidad del viento hasta la temperatura, en total 23 variables recogidas durante varios años en distintas ciudades de Australia con las que se obtienen un dataset de 140.000 líneas aproximadamente.

Nuestro objetivo será predecir la lluvia del día siguiente a partir los datos metereológicos del día (vamos a realizar una regresión logística). Nos interesará tener una matriz de confusión dónde los verdaderos positivos y los verdaderos negativos sean altos. Sobretodo nos interesará que los verdaderos positivos, es decir predecir que llueve el día siguiente, lo predice bien el modelo. 

Además, no sólo nos interesa predecir bien si llueve o no el siguiente día, sino entender bien qué factores metereológicos tienen más influencia en la respuesta final. Cómo afecta cada uno de ellos según si su valor aumenta o disminuye.

Para ello, antes que nada hay que entender bien las variables del dataset, qué describen, en qué rangos se mueven, sus valores atípicos y cómo se podrían transformar para poder introducirlas al modelo con la distribución óptima.

Con este dataset tan grande lo primero que nos planteamos fue centrarnos en dos cosas:
  
  1. Utilizar una zona concreta de Australia, sacada de la variable localización, de la cual elegimos 4 ciudades situadas en la costa sureste de Australia.

2. Utilizar la variable temporal de alguna forma, ya que considerabamos que tenía importancia pero no podíamos usar cada día del año como un dato diferente, por lo que decidimos obtener a partir de la fecha la estación del año en la que estaba cada línea.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r librerias y seed, echo = FALSE, include=FALSE, message=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(VIM)
library(wesanderson)
library(GGally)
library(corrplot)
library(mice)
library(egg)
library(kableExtra)
library(car)
library(fastDummies)
library(caret)
library(glmnet)
library(blorr)
library(magrittr)
library(tidyr)
library(tidyverse)
library(ggplot2)
library(RColorBrewer)
library(VIM)
library(visdat)
library(naniar)
library(caTools)
library(corrplot)
library(pROC)
library(ggthemes)
library(cowplot)
```

```{r Dataset train y test, include=FALSE}
weatherAUS <- read_csv("weatherAUS_2.csv")

set.seed(123)
train_ind <- sample(seq_len(nrow(weatherAUS)), size = 0.80 * nrow(weatherAUS))
train <- weatherAUS[train_ind, ]
temp <- weatherAUS[-train_ind, ]
test_val_ind<- sample(seq_len(nrow(temp)), size = 0.50 * nrow(temp))
test <- temp[test_val_ind, ]
validation <- temp[-test_val_ind, ]

```

```{r head}
head(train)
```

```{r dimensiones, echo=FALSE}
cat(" Dimensiones dataset train: ", dim(train)) 
cat(" Dimensiones dataset test: ", dim(test)) 
cat(" Dimensiones dataset validación: ", dim(validation)) 
```

Antes que nada, visualizamos información básica de las ciudades elegidas y estaciones y cómo están relacionadas con la lluvia. 

Realizamos un conteo del número de días que han llovido o no en cada una.

```{r location, echo=FALSE,  fig.align='center'}
var_location = train$Location
# Comparación con el target
ggplot(train, aes(Location)) + geom_bar(aes( fill = RainTomorrow), position = position_dodge(0.9)) + theme(axis.text.x=element_text(angle=90,hjust=1)) + scale_fill_manual('RainTomorrow', values = c("No" = "lightsteelblue", "Yes" = "deepskyblue4"))
```

Si filtramos por los días en los que ha llovido hoy (RainToday = 1), vemos las veces que ha llovido el día siguiente o no.

```{r rain today rain tomorrow, echo=FALSE,  fig.align='center'}

train_llueve_hoy = train %>% filter((RainToday == 'Yes'))
ggplot(train_llueve_hoy, aes(Location)) + geom_bar(aes( fill = RainTomorrow), position = position_dodge(0.9)) + theme(axis.text.x=element_text(angle=90,hjust=1)) + scale_fill_manual('RainTomorrow', values = c("No" = "lightsteelblue", "Yes" = "deepskyblue4"))

```

Vemos que en Adelaide, Canberra y Melbourne no suele ser fuecuente que llueva el día siguiente si ha llovido hoy. En Sydney en cambio, es más fequente que llueva si ha llovido el día anterior.

Representamos ahora los días que han llovido en función de las ciudades y las estaciones del año.

```{r location and season, echo=FALSE,  fig.align='center'}
# Comparación con las estaciones
train_llueve = train %>% filter((RainTomorrow == 'Yes'))
ggplot(train_llueve, aes(Location)) + geom_bar(aes( fill = Season), position = position_dodge(0.9)) + theme(axis.text.x=element_text(angle=90,hjust=1)) 
```

En Adelaide y Melbourne las estaciones sí influyen más en la frecuencia de días que llueven, mientras que en Sydney y Canberra suele ser más homogénero.

## EDA variables individuales
Resumen de las variables.

```{r summary}
summary(train)
```

Analizamos las variables individuales por separado con distintos gráficos.

En este dataset hay muchos pares de variables que están fuertemente relacionadas, por ejemplo la temperatura máxima y mínima de un día, o la presión a las 9 de la mañana y la presión a las 3 de la tarde. Por ello, en el análisis individual de variables se estudiarán a la vez por una mejor comprensión.

### MinTemp y MaxTemp
```{r MinTemp y MaxTemp, echo=FALSE,  fig.align='center'}
# Basic histogram
hist_MinTemp = ggplot(train, aes(x=MinTemp)) + geom_histogram() + ggtitle('Histograma Temperatura Mínima')
hist_MaxTemp = ggplot(train, aes(x=MaxTemp)) + geom_histogram() + ggtitle('Histograma  Temperatura Máxima')
# Basic Density plot
density = ggplot(train, aes(x = MinTemp)) + geom_density(fill="white") + ggtitle('Función de densidad de la Temperatura Mínima')
# Basic box plot
boxplot_MinTemp = ggplot(train, aes(y=MinTemp)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Temperatura Mínima')
boxplot_MaxTemp = ggplot(train, aes(y=MaxTemp)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Temperatura Máxima')
grid.arrange(hist_MinTemp, hist_MaxTemp, boxplot_MinTemp, boxplot_MaxTemp,  nrow = 2)
```

La temperatura mínima se podría asimilar a una distribución normal. La temperatura máxima tiene una cola a su derecha en la que aparecen mútliples valores atípicos.

### Temp9am y Temp3pm
Las variables Temp9am y Temp3pm son muy parecidas a las temperaturas mínimas y máximas respectivamente.

```{r Temp9am y Temp3pm, echo=FALSE,  fig.align='center'}
# Basic histogram
hist_Temp9am = ggplot(train, aes(x=Temp9am)) + geom_histogram() + ggtitle('Histograma Temperatura 9am')
hist_Temp3pm = ggplot(train, aes(x=Temp3pm)) + geom_histogram() + ggtitle('Histograma  Temperatura 3pm')
# Basic Density plot
density = ggplot(train, aes(x = MinTemp)) + geom_density(fill="white") + ggtitle('Función de densidad de la Temperatura 9am')
# Basic box plot
boxplot_Temp9am = ggplot(train, aes(y=Temp9am)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Temperatura 9am')
boxplot_Temp3pm = ggplot(train, aes(y=Temp3pm)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Temperatura 3pm')
grid.arrange(hist_Temp9am, hist_Temp3pm, boxplot_Temp9am, boxplot_Temp3pm,  nrow = 2)
```

Estas variables tienen un comportamiento parecido a la temperatura mínima y máxima respectivamente.

### Pressure9am y Pressure3pm
```{r Pressure9am y Pressure3pm, echo=FALSE,  fig.align='center'}
# Basic histogram
hist_Pressure9am = ggplot(train, aes(x=Pressure9am)) + geom_histogram() + ggtitle('Histograma Presión 9am')
hist_Pressure3pm = ggplot(train, aes(x=Pressure3pm)) + geom_histogram() + ggtitle('Histograma  Presión 3pm')
# Basic Density plot
density = ggplot(train, aes(x = Pressure9am)) + geom_density(fill="white") + ggtitle('Función de densidad de la Temperatura 9am')
# Basic box plot
boxplot_Pressure9am= ggplot(train, aes(y=Pressure9am)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Presión 9am')
boxplot_Pressure3pm = ggplot(train, aes(y=Pressure3pm)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Presión 3pm')
grid.arrange(hist_Pressure9am, hist_Pressure3pm, boxplot_Pressure9am, boxplot_Pressure3pm,  nrow = 2)
```

Parecen tener una distribución normal ambas variables.

### Humidity9am y Humidity3pm

```{r Humidity9am y Humidity3pm, echo=FALSE,  fig.align='center'}
# Basic histogram
hist_Humidity9am = ggplot(train, aes(x=Humidity9am)) + geom_histogram() + ggtitle('Histograma Humedad 9am')
hist_Humidity3pm = ggplot(train, aes(x=Humidity3pm)) + geom_histogram() + ggtitle('Histograma  Humedad 3pm')
# Basic Density plot
density = ggplot(train, aes(x = Humidity9am)) + geom_density(fill="white") + ggtitle('Función de densidad de la Temperatura 9am')
# Basic box plot
boxplot_Humidity9am= ggplot(train, aes(y=Humidity9am)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Humedad 9am')
boxplot_Humidity3pm = ggplot(train, aes(y=Humidity3pm)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Humedad 3pm')
grid.arrange(hist_Humidity9am, hist_Humidity3pm, boxplot_Humidity9am, boxplot_Humidity3pm,  nrow = 2)
```

### Cloud9am y Cloud3pm

```{r Cloud9am y Cloud3pm, echo=FALSE,  fig.align='center'}
hist_Cloud9am = ggplot(train, aes(x=Cloud9am)) + geom_histogram() + ggtitle('Histograma Nubes 9am')
hist_Cloud3pm = ggplot(train, aes(x=Cloud3pm)) + geom_histogram() + ggtitle('Histograma  Nubes 3pm')
grid.arrange(hist_Cloud9am, hist_Cloud3pm,  nrow = 1)
```

Se trata de una variable categórica que indica la fracción del cielo que está cubierta por nubes a las 9am. Está medida en "oktas", que son unidades de octavos. Una medida cero indica que el cielo está completamente despejado y un ocho indica que está completamente cubierto.

La variable a las diferentes horas se distribuye de forma muy parecida.

### WindSpeed9am y WindSpeed3pm

```{r WindSpeed9am y WindSpeed3pm, echo=FALSE,  fig.align='center'}
# Basic histogram
hist_WindSpeed9am = ggplot(train, aes(x=WindSpeed9am)) + geom_histogram() + ggtitle('Histograma Velocidad viento 9am')
hist_WindSpeed3pm = ggplot(train, aes(x=WindSpeed3pm)) + geom_histogram() + ggtitle('Histograma Velocidad viento 3pm')

# Basic box plot
boxplot_WindSpeed9am = ggplot(train, aes(y=WindSpeed9am)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Velocidad viento 9am')
boxplot_WindSpeed3pm = ggplot(train, aes(y=WindSpeed3pm)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Velocidad viento 3pm')
grid.arrange(hist_WindSpeed9am, hist_WindSpeed3pm, boxplot_WindSpeed9am, boxplot_WindSpeed3pm,  nrow = 2)
```

La velocidad del viente suele tomar valores mayores por la tarde, a las 3pm comparado con la mañana.

### WindDir9am y WindDir3pm
```{r WindDir9am y WindDir3pm, echo=FALSE,  fig.align='center'}
plot_WindDir9am = ggplot(train, aes(x=WindDir9am)) + geom_bar() + ggtitle('Histograma Dirección viento 9am') + theme(axis.text.x=element_text(angle=90,hjust=1))
plot_WindDir3pm = ggplot(train, aes(x=WindDir3pm)) + geom_bar() + ggtitle('Histograma  Dirección viento 3pm') + theme(axis.text.x=element_text(angle=90,hjust=1))
grid.arrange(plot_WindDir9am, plot_WindDir3pm,  nrow = 1)
```

Las direcciones en las que el viento se mueve son muy diferentes a las 9 y a las 3. Predominan la dirección Norte y la Oeste por la mañana, mientras que por la tarde suele ser más homogéneo.

### Velocidad más fuerte del viento
```{r WindGustSpeed y WindGustDir, echo=FALSE,  fig.align='center'}
plot_WindDir = ggplot(train, aes(x=WindGustDir)) + geom_bar() + ggtitle('Histograma Dirección máximo viento diario')
# Basic histogram
hist_WindGustSpeed = ggplot(train, aes(x=WindGustSpeed)) + geom_histogram() + ggtitle('Histograma Dirección máximo viento diario')
# Basic box plot
boxplot_WindGustSpeed = ggplot(train, aes(y=WindGustSpeed)) +  geom_boxplot(fill="white")  + ggtitle('Boxplot Dirección viento más fuerte en las últimas 24h') + theme(axis.text.x=element_text(angle=90,hjust=1))

grid.arrange(hist_WindGustSpeed, boxplot_WindGustSpeed, nrow = 1)
plot_WindDir
```

Se trata de la dirección y la velocidad del viento más fuerte en las últimas 24 horas. Predomina el viento en la dirección norte con una media de veolcidad de 40km/h.

Analizamos cuatro variables que no están, a priori, relacionadas por pares.

### Rainfall

```{r Rainfall, echo=FALSE,  fig.align='center'}
hist_Rainfall = ggplot(train, aes(x=Rainfall)) + geom_histogram() + ggtitle('Histograma Rainfall')
boxplot_Rainfall = ggplot(train, aes(y=Rainfall)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Rainfall')
grid.arrange(hist_Rainfall, boxplot_Rainfall, nrow = 1)
```

Es la cantidad de lluvia que se ha registrado en el día en mm. Como la mayoría de días no llueve, aparecen muchos valores nulos en el histograma que dificulta la normalización de la variable. 

### Evaporation

```{r Evaporation, echo=FALSE,  fig.align='center'}
hist_Evaporation = ggplot(train, aes(x=Evaporation)) + geom_histogram() + ggtitle('Histograma Evaporation')
boxplot_Evaporation = ggplot(train, aes(y=Evaporation)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Evaporation')
grid.arrange(hist_Evaporation, boxplot_Evaporation, nrow = 1)
```

Se trata de la evaporación en mm en las últimas 24h a las 9am. Contiene un gran número de valroes atípicos.

### Horas de sol

```{r Sunshine4, echo=FALSE,  fig.align='center'}
hist_Sunshine = ggplot(train, aes(x=Sunshine)) + geom_histogram() + ggtitle('Histograma Sunshine')
boxplot_Sunshine = ggplot(train, aes(y=Sunshine)) +  geom_boxplot(fill="white") + ggtitle('Boxplot Sunshine')
grid.arrange(hist_Sunshine, boxplot_Sunshine, nrow = 1)
```

Sorprende el número de días en el que las horas de sol es 0, es decir, está nublado todo el día o con rayos de sol muy débiles.

## EDA multivariante
Analizamos la relación unas variables con  otras.

```{r corrplot, echo=FALSE,  fig.align='center'}
#Correlación variables numéricas
train_num = train %>% select_if(is.numeric) %>% na.omit()
train_matrix = cor(train_num)
corrplot(train_matrix,is.corr = FALSE, method='circle', order = "hclust", addrect = 2, tl.cex=0.8, tl.col = "black")
```

Gracias a este gráfico demostramos que los pares de variables citados sí están fuertemente relacionados. Por ejemplo, la presión a las 9 de la mañana con la presión a las 3 de la tarde: si una aumenta, la otra también. Destacar que también hay correlaciones inversas: cuando aumenta la variable Sunshine, disminuye la Cloud9am.

Analizamos en general la relación entre las variables con las estaciones, la variable de salida (RainTomorrow) y las ciudades. Para ello seleccionamos una de las variables de los pares (ya que contienen información similar) y el resto. La variable Rainfall no la mostramos pues su distribución es difícil de visualizar. Se analizarán posteriormente con las transformaciones.

Relaciones por estaciones.

```{r , echo=FALSE,  fig.align='center'}
new_train = train %>% select("Season", "MaxTemp","Temp9am","Cloud9am","WindGustSpeed", "Humidity3pm", "Pressure3pm", "Evaporation", "Sunshine")

numeric <- map_lgl(new_train, is.numeric)

new_train %>% select(1, 2:9) %>%
  na.omit() %>%
  ggpairs(columns = 2:9, ggplot2::aes(colour=Season))
```

La Temperatura (MaxTemp, Temp9am), la presión (Pressure3pm) y evaporación muestran un claro comportamiento diferente según la estación.

Relaciones por ciudades.

```{r , echo=FALSE,  fig.align='center'}
new_train = train %>% select("Location", "MaxTemp","Temp9am","Cloud9am","WindGustSpeed", "Humidity3pm", "Pressure3pm", "Evaporation", "Sunshine")

numeric <- map_lgl(new_train, is.numeric)

new_train %>% select(1, 2:9) %>%
  na.omit() %>%
  ggpairs(columns = 2:9, ggplot2::aes(colour=Location))
```

La temperatura es la variable dónde se puede observar más claramente que tiene un comportamiento diferente para cada ciudad.

Relaciones por RainTomorrow, si llueve o no.

```{r , echo=FALSE,  fig.align='center'}
new_train = train %>% select("RainTomorrow", "MaxTemp","Temp9am","Cloud9am","WindGustSpeed", "Humidity3pm", "Pressure3pm", "Evaporation", "Sunshine")

numeric <- map_lgl(new_train, is.numeric)

new_train %>% select(1, 2:9) %>%
  na.omit() %>%
  ggpairs(columns = 2:9, ggplot2::aes(colour=RainTomorrow))
```

Las variables interesantes a analizar con más detalle son: la temperatura, la humedad, la presión y los rayos de sol.

A partir de estas relaciones, indagamos con más detalle las relaciones que parecen interesantes.

Comprobamos que, efectivamente, las cuatro variables de temperatura son muy parecidas, como puede observarse en sus distribuciones:

```{r , echo=FALSE,  fig.align='center'}
density_MinTemp = train %>%
  mutate(test = factor(RainTomorrow, labels = c('negative', 'positive'))) %>%
  ggplot(aes(x = MinTemp, fill = test)) + 
  geom_density(alpha = .3) +
  ggtitle('MinTemp - RainTomorrow')

density_MinTemp = train %>%
  mutate(test = factor(RainTomorrow, labels = c('negative', 'positive'))) %>%
  ggplot(aes(x = MinTemp, fill = test)) + 
  geom_density(alpha = .3) +
  ggtitle('MaxTemp - RainTomorrow')

density_Temp9am = train %>%
  mutate(test = factor(RainTomorrow, labels = c('negative', 'positive'))) %>%
  ggplot(aes(x = Temp9am, fill = test)) + 
  geom_density(alpha = .3) +
  ggtitle('Temp9am - RainTomorrow')

density_Temp3pm = train %>%
  mutate(test = factor(RainTomorrow, labels = c('negative', 'positive'))) %>%
  ggplot(aes(x = Temp3pm, fill = test)) + 
  geom_density(alpha = .3) +
  ggtitle('Temp3pm - RainTomorrow')

grid.arrange(density_MinTemp, density_MinTemp, density_Temp9am, density_Temp3pm,  nrow = 2)
```

Al estar relacionadas y tener un comportamiento similar posteriormente se estudiará introdudir al modelo interacciones entre éstas.

Veamos cómo se comporta una de ellas según las estaciones y ciudades:

```{r , echo=FALSE,  fig.align='center'}
boxplot_Temp9am_season = train %>%
  mutate(Estaciones = factor(Season)) %>%
  ggplot(aes(y = Temp9am, fill = Estaciones)) + 
  geom_boxplot() +
  ggtitle('Temp9am - Season')

boxplot_Temp9am_location = train %>%
  mutate(Ciudades = factor(Location)) %>%
  ggplot(aes(y = Temp9am, fill = Ciudades)) + 
  geom_boxplot() +
  ggtitle('Temp9am - Location')

grid.arrange(boxplot_Temp9am_season, boxplot_Temp9am_location, nrow = 2)
```

La Temperatura claramente está condicionada por las estaciones y por las ciudades. No hay mucha diferencia entre otoño y primavera. Dada esta información se podría plantear realizar un modelo para cada estación o para cada ciudad.

Comprobamos que los pares de temperaturas están fuertemente relacionados y que por lo tanto será interesante estudiar interacciones entre ellas.

```{r , echo=FALSE,  fig.align='center'}

scatterplot_Temph = qplot(Temp9am, Temp3pm, data = train, colour = factor(RainTomorrow)) +
  geom_smooth() + ggtitle('Temperaturas a diferentes horas y RainTomorrow')

scatterplot_Temp = qplot(MinTemp, MaxTemp, data = train, colour = factor(RainTomorrow)) +
  geom_smooth() + ggtitle('Temperaturas máximas y mínimas y RainTomorrow')

grid.arrange(scatterplot_Temph, scatterplot_Temp, nrow = 2)
```

Analizamos otras variables más en detalle.
Veamos cómo se comporta la presión según las estaciones y ciudades:

```{r , echo=FALSE,  fig.align='center'}
boxplot_Pressure9am_season = train %>%
  mutate(Estaciones = factor(Season)) %>%
  ggplot(aes(y = Pressure9am, fill = Estaciones)) + 
  geom_boxplot() +
  ggtitle('Pressure9am - Season')

boxplot_Pressure9am_RainTomorrow = train %>%
  mutate(RainTomorrow = factor(RainTomorrow)) %>%
  ggplot(aes(y = Pressure9am, fill = RainTomorrow)) + 
  geom_boxplot() +
  ggtitle('Pressure9am - RainTomorrow')

grid.arrange(boxplot_Pressure9am_season, boxplot_Pressure9am_RainTomorrow, nrow = 2)
```

La presión se diferencia bastante con cada estación y también se aprecia que está bastante relacionada con si llueve o no: la presión suele ser menor cuando llueve.
  
Comprobamos que las variables de presión están fuertemente relacionadas entre ellas. 
```{r , echo=FALSE,  fig.align='center'}

scatterplot_Presion = qplot(Pressure9am, Pressure3pm, data = train, colour = factor(RainTomorrow)) + ggtitle('Presión a diferentes horas y RainTomorrow')

scatterplot_Presion
```


Veamos cómo se comporta la humedad según las estaciones y ciudades:

```{r , echo=FALSE,  fig.align='center'}
boxplot_Humidity9am_season = train %>%
  mutate(Estaciones = factor(Season)) %>%
  ggplot(aes(y = Humidity9am, fill = Estaciones)) + 
  geom_boxplot() +
  ggtitle('Humidity9am - Season')

boxplot_Humidity9am_RainTomorrow = train %>%
  mutate(RainTomorrow = factor(RainTomorrow)) %>%
  ggplot(aes(y = Humidity9am, fill = RainTomorrow)) + 
  geom_boxplot() +
  ggtitle('Humidity9am - RainTomorrow')

grid.arrange(boxplot_Humidity9am_season, boxplot_Humidity9am_RainTomorrow, nrow = 2)
```

Vemos que la humedad contiene valores diferentes según si llueve o no y se diferencia básicamente entre otoño e invierno. Efectiavmente la humedad es mayor los días que llueve.

Comprobamos cómo de relacionadas están las variables de humedad entre ellas.

```{r , echo=FALSE,  fig.align='center'}

scatterplot_Humedad = qplot(Humidity9am, Humidity3pm, data = train, colour = factor(RainTomorrow)) + ggtitle('Humedad a diferentes horas y RainTomorrow')

scatterplot_Humedad
```

Veamos cómo se comporta la evaporación según las estaciones y ciudades:

```{r , echo=FALSE,  fig.align='center'}
boxplot_Evaporation_season = train %>%
  mutate(Estaciones = factor(Season)) %>%
  ggplot(aes(y = Evaporation, fill = Estaciones)) + 
  geom_boxplot() +
  ggtitle('Evaporation - Season')

boxplot_Evaporation_location = train %>%
  mutate(Ciudades = factor(Location)) %>%
  ggplot(aes(y = Evaporation, fill = Ciudades)) + 
  geom_boxplot() +
  ggtitle('Temp9am - Evaporation')

grid.arrange(boxplot_Evaporation_season, boxplot_Evaporation_location, nrow = 2)
```

Se observan comportamientos diferentes de la evaporación sobretodo en función de las estaciones.

Veamos cómo se comportan las horas de sol según las estaciones y ciudades:

```{r , echo=FALSE,  fig.align='center'}
boxplot_Sunshine_season = train %>%
  mutate(Estaciones = factor(Season)) %>%
  ggplot(aes(y = Sunshine, fill = Estaciones)) + 
  geom_boxplot() +
  ggtitle('Sunshine - Season')

boxplot_Sunshine_RainTomorrow = train %>%
  mutate(RainTomorrow = factor(RainTomorrow)) %>%
  ggplot(aes(y = Sunshine, fill = RainTomorrow)) + 
  geom_boxplot() +
  ggtitle('Sunshine - RainTomorrow')

grid.arrange(boxplot_Sunshine_season, boxplot_Sunshine_RainTomorrow, nrow = 2)
```

Claramente la variable sunshine se diferencia más en función de la variable de salida RainTomorrow.

Veamos cómo se comporta la velocidad del viento según las estaciones y ciudades:

```{r , echo=FALSE,  fig.align='center'}
boxplot_WindGustSpeed_season = train %>%
  mutate(test = factor(Season)) %>%
  ggplot(aes(y = WindGustSpeed, fill = test)) + 
  geom_boxplot() +
  ggtitle('WindGustSpeed - Season')

boxplot_WindGustSpeed_RainTomorrow = train %>%
  mutate(RainTomorrow = factor(RainTomorrow)) %>%
  ggplot(aes(y = WindGustSpeed, fill = RainTomorrow)) + 
  geom_boxplot() +
  ggtitle('WindGustSpeed - RainTomorrow')

grid.arrange(boxplot_WindGustSpeed_season, boxplot_WindGustSpeed_RainTomorrow, nrow = 2)
```

La velocidad del viento suele ser mayor los días que llueve.

Veamos cómo se comportan las nubes del viento según las estaciones y ciudades:
```{r , echo=FALSE,  fig.align='center'}

barplot_cloud9am = ggplot(train, aes(Cloud9am)) + geom_bar(aes(fill = RainTomorrow), position = position_dodge(0.9)) + theme(axis.text.x=element_text(angle=90,hjust=1)) 

barplot_cloud3pm = ggplot(train, aes(Cloud3pm)) + geom_bar(aes(fill = RainTomorrow), position = position_dodge(0.9)) + theme(axis.text.x=element_text(angle=90,hjust=1)) 

grid.arrange(barplot_cloud9am, barplot_cloud3pm, nrow = 2)
```

Las variables de nubes a las diferentes horas se comportan de manera muy parecida.

Veamos cómo se comportan la velocidad del viento y su dirección según las estaciones y ciudades:

```{r , echo=FALSE,  fig.align='center'}

train %>%
  group_by(WindDir3pm, RainTomorrow) %>% 
  summarise(avg_WindSpeed3pm = mean(WindSpeed3pm)) %>%
  ggplot(aes(x=WindDir3pm, y=avg_WindSpeed3pm, fill=RainTomorrow)) + geom_bar(stat ="identity", position = "dodge") + ggtitle("Relación entre dirección de viento y velocidad con la lluvia del día siguiente")
```

No parece haber mucha diferencia entre la dirección del viento y la velocidad en función de si llueve o no.

Añadir estos gráficos (Rainfall) después de analizar las transformaciones.


```{r , echo=FALSE,  fig.align='center'}
#Aplicar a la transformación de RainFall
boxplot_Rainfall_season = train %>%
  mutate(test = factor(Season)) %>%
  ggplot(aes(y = 1/(Rainfall +1) , fill = test)) + 
  geom_boxplot() +
  ggtitle('1/(Rainfall + 1) - Season')

boxplot_Rainfall_location = train %>%
  mutate(test = factor(Location)) %>%
  ggplot(aes(y = 1/( Rainfall +1), fill = test)) + 
  geom_boxplot() +
  ggtitle('1/(Rainfall +1) - Location')

grid.arrange(boxplot_Rainfall_season, boxplot_Rainfall_location, nrow = 2)
```


## Interacción entre variables y combinaciones

Se puede observar en la gráfica siguiente que ninguna variable individual es mejor que otra para diferenciar si llueve o no llueve, estudiaremos `MinTemp`, `MaxTemp`, `Temp9am`, `Temp3pm`, `Pressure9am`, `Pressure3pm`, `Humidity9am`, `Humidity3pm`.

```{r interaccion, echo=FALSE,  fig.align='center'}

boxplot_vars <- function(var, title) {
  
  ggplot(train, aes(x = RainTomorrow, y = var)) +
    geom_violin() +
    theme_hc() + 
    stat_summary(fun.data = "mean_sdl", colour="blue") +
    ylab(title)
  
}


mintemp <- boxplot_vars(train$MinTemp, "MinTemp")
maxtemp <- boxplot_vars(train$MaxTemp, "MaxTemp")
temp9 <- boxplot_vars(train$Temp9am, "Temp9am")
temp3 <- boxplot_vars(train$Temp3pm, "Temp3pm")
press9 <- boxplot_vars(train$Pressure9am, "Pressure9am")
press3 <- boxplot_vars(train$Pressure3pm, "Pressure3pm")
humidity9 <- boxplot_vars(train$Humidity9am, "Humiditye9am")
humidity3 <- boxplot_vars(train$Humidity3pm, "Humidity3pm")
windspeed9 <- boxplot_vars(train$WindSpeed9am, "WindSpeed9am")
windspeed3 <- boxplot_vars(train$WindSpeed3pm, "WindSpeed3pm")
plot_grid(mintemp, maxtemp, temp9, temp3, press9, press3, humidity9, humidity3, windspeed9, windspeed3, nrow = 5, ncol = 2)
```


Ahora crearemos unas nuevas varibles combinándolas entre sí.
Las usaremos en el modelo más adelante para ajustarlo.

```{r grafico violin nuevas variables, echo=FALSE, fig.align='center'}

train$AvgTemp <- round(rowMeans(train[c('MinTemp', 'MaxTemp')], na.rm=TRUE),digits=2)
train$Temp <- round(rowMeans(train[c('Temp9am', 'Temp3pm')], na.rm=TRUE),digits=2)
train$Pressure <- round(rowMeans(train[c('Pressure9am', 'Pressure3pm')], na.rm=TRUE),digits=2)
train$Humidity <- round(rowMeans(train[c('Humidity9am', 'Humidity3pm')], na.rm=TRUE),digits=2)
train$WindSpeed <- round(rowMeans(train[c('WindSpeed9am', 'WindSpeed3pm')], na.rm=TRUE),digits=2)

#Test
test$AvgTemp <- round(rowMeans(test[c('MinTemp', 'MaxTemp')], na.rm=TRUE),digits=2)
test$Temp <- round(rowMeans(test[c('Temp9am', 'Temp3pm')], na.rm=TRUE),digits=2)
test$Pressure <- round(rowMeans(test[c('Pressure9am', 'Pressure3pm')], na.rm=TRUE),digits=2)
test$Humidity <- round(rowMeans(test[c('Humidity9am', 'Humidity3pm')], na.rm=TRUE),digits=2)
test$WindSpeed <- round(rowMeans(test[c('WindSpeed9am', 'WindSpeed3pm')], na.rm=TRUE),digits=2)


AvgTemp <- boxplot_vars(train$AvgTemp, "AvgTemp")
temp <- boxplot_vars(train$Temp, "Temp")
press <- boxplot_vars(train$Pressure, "press")
humidity <- boxplot_vars(train$Humidity, "Humidity")
wind_speed <- boxplot_vars(train$WindSpeed, "WindSpeed")


plot_grid(AvgTemp, temp, press, humidity,wind_speed, nrow = 5, ncol = 1)

```


## Imputación de datos faltantes

Vamos a realizar un estudio de los datos faltantes para después imputarlos utilizando las técnicas junto al resto de parámetros.

Para analizar los posibles datos faltantes y las relaciones utilizamos dos bibliotecas, visdat y naniar. Con la base de datos de train vemos como se reparten los datos faltantes.

```{r visualitation data}
vis_dat(train)
(cols_withNa <- apply(train, 2, function(x) sum(is.na(x))))
```

```{r Todo}
# TODO revisar texto y poner markdown 
```

Con estos datos podemos deducir que las variables con más datos faltantes serían (de más a menos datos faltantes):
  - Cloud3pm
  - Cloud9am
  - Sunshine
  - Evaporation
  - WindGustDir
  - WindGustSpeed
  - WindDir9am
  
Con estos datos vamos a estudiar cuáles son las variables con más relaciones de los valores faltantes.

```{r visualitation data 2}
gg_miss_upset(train)
```

Con esta gráfica podemos observar que los datos faltantes más relaccionados son sobretodo Cloud3pm y Cloud9am, esto puede deberse a que estas variables son categóricas y no pueden medirse directamente, ya que necesitan de la evaluación del cielo en ese día y esto puede que este automatizado.

A estas variables se le suman las variables Evaporation y Sunshine, que también están relaccionadas tanto entre sí como con las mencionadas anteriormente.

Por último recalcar que la variable WindGustDir tiene muchos datos faltantes en los que no tiene relación con las antes mencionadas. Esto puede deberse a que miden cosas completamente diferentes y no necesariamente dependen de las otras.

Con todos estos datos y el EDA con el que hemos empezado podemos comenzar a imputar datos faltantes:

Las primeras variables que vamos a evaluar para completar sus datos faltantes son aquellas variables numéricas que se miden en dos momentos del día, esto nos puede ayudar para completar una con la otra ya que en gran medida estas variables son bastante dependientes y podemos sacar una buena correlación para completar una con la otra.

Para esto utilizaremos el metodo de imputación KNN, con estos datos consideramos que se pueden completar perfectamente estos valores faltantes.

Variables Temp9am & Temp3pm: 
```{r imputacion1}
#Variables Temp9am & Temp3pm: método: imputación simple: KNN
par(mfrow=c(1,1))
train %>% select(Temp9am, Temp3pm) %>% marginplot()
```

Viendo esta gráfica podemos decir que tiene sentido utilizar la imputación mediante KNN.

```{r imputacion11}
#Posible imputación simple mediante un algoritmo de clustering k-NN (con la función VIM:kNN)
#Parece que tiene sentido:
train %>% select(Temp9am, Temp3pm) %>% VIM::kNN() %>% marginplot(., delimiter="_imp")
train_imputed <- kNN(train, variable=c("Temp9am","Temp3pm"))
#test_imputed <- kNN(test, variable=c("Temp9am","Temp3pm"))

```

Comprobamos si nuestra muestra inicial modifica su densidad para asegurarnos de que esta imputación funciona y no hemos generado ningún valor que no coincida.

```{r imputacion2}
#Comprobaciones:
par(mfrow=c(1,2))
plot(density(train$Temp9am, na.rm = T), col=2, main="Temp9am")
lines(density(train_imputed$Temp9am), col=3)
plot(density(train$Temp3pm, na.rm = T), col=2, main="Temp3pm")
lines(density(train_imputed$Temp3pm), col=3) 
```

Como podemos comprobar, apenas se aprecia la linea roja que esta debajo de la densidad inicial por lo que podemos decir que no cambia.

Variables MinTemp & MaxTemp:
```{r imputacion22}
#Variables MinTemp & MaxTemp: método: imputación simple: KNN
par(mfrow=c(1,1))
train %>% select(MinTemp, MaxTemp) %>% marginplot()
#Parece que tiene sentido:
train %>% select(MinTemp, MaxTemp) %>% VIM::kNN() %>% marginplot(., delimiter="_imp")
train_imputed <- kNN(train, variable=c("MaxTemp","MinTemp"))
#test_imputed <- kNN(test, variable=c("MaxTemp","MinTemp"))
```
```{r imputacion5}
#Comprobaciones:
par(mfrow=c(1,2))
plot(density(train$MaxTemp,na.rm = T),col=2,main="MaxTemp")
lines(density(train_imputed$MaxTemp),col=3)
plot(density(train$MinTemp,na.rm = T),col=2,main="MinTemp")
lines(density(train_imputed$MinTemp),col=3)
```

En este caso la imputación de datos faltantes también funciona.

Variables Pressure9am & Pressure3pm:
```{r imputacion humidity2}
#Variables Pressure3pm & Pressure9am: método: imputación simple: KNN
par(mfrow=c(1,1))
train %>% select(Pressure3pm, Pressure9am) %>% marginplot()
#Parece que tiene sentido:
train %>% select(Pressure3pm, Pressure9am) %>% VIM::kNN() %>% marginplot(., delimiter="_imp")
train_imputed <- kNN(train_imputed, variable=c("Pressure3pm","Pressure9am"))
#test_imputed <- kNN(test_imputed, variable=c("Pressure3pm","Pressure9am"))

```
```{r imputacion4.5}
#Comprobaciones:
par(mfrow=c(1,2))
plot(density(train$Pressure3pm,na.rm = T),col=2,main="Pressure3pm")
lines(density(train_imputed$Pressure3pm),col=3)
plot(density(train$Pressure9am,na.rm = T),col=2,main="Pressure9am")
lines(density(train_imputed$Pressure9am),col=3)
```
Podemos utilizar esta imputación en la presión.

Variables Humidity9am & Humidity3pm:
```{r imputacion humidity1.5}
#Variables Humidity9am & Humidity3pm: método: imputación simple: KNN
par(mfrow=c(1,1))
train %>% select(Humidity3pm, Humidity9am) %>% marginplot()
#Parece que tiene sentido:
train %>% select(Humidity3pm, Humidity9am) %>% VIM::kNN() %>% marginplot(., delimiter="_imp")
train_imputed <- kNN(train_imputed, variable=c("Humidity3pm","Humidity9am"))
#test_imputed <- kNN(test_imputed, variable=c("Humidity3pm","Humidity9am"))

```
```{r imputacion4.6}
#Comprobaciones:
par(mfrow=c(1,2))
plot(density(train$Humidity3pm,na.rm = T),col=2,main="Humidity3pm")
lines(density(train_imputed$Humidity3pm),col=3)
plot(density(train$Humidity9am,na.rm = T),col=2,main="Humidity9am")
lines(density(train_imputed$Humidity9am),col=3)
```
Podemos utilizar esta imputación en la humedad.

Variables Rainfall & Raintoday:
Podríamos pensar que estas dos variables van de la mano, ya que si la premisa se cumple, cuando la variable Rainfall es 0 es que ese mismo día no ha llovido, por ello haremos un estudio de los datos faltantes.
```{r imputacion faltantes RainToday y Rainfall}
trainSelect2 <- train %>% select(RainToday, Rainfall)
gg_miss_upset(trainSelect2)
```
Esto quiere decir que los datos faltantes son exactamente los mismos, por lo que vamos a proceder a completar los datos faltantes de la variable rainfall y con ellos completaremos los datos de Raintoday.

Otras variables que puede tener sentido relacionar es la cantidad de lluvia con la humedad.

Variables Humidity9am & Rainfall:
```{r imputacion humidity}
#Variables Humidity9am & Rainfall: método: imputación simple: KNN
par(mfrow=c(1,1))
train %>% select(Humidity9am, Rainfall) %>% marginplot()
#Parece que tiene sentido:
train %>% select(Humidity9am, Rainfall) %>% VIM::kNN() %>% marginplot(., delimiter="_imp")
train_imputed <- kNN(train_imputed, variable=c("Humidity9am","Rainfall"))
# test_imputed <- kNN(test_imputed, variable=c("Humidity9am","Rainfall"))



```

```{r test_imputed}

train_imputed[c("Temp9am_imp","Temp3pm_imp" ,"MaxTemp_imp","MinTemp_imp", "Humidity9am_imp","Rainfall_imp", "Humidity3pm_imp", "Pressure3pm_imp","Pressure9am_imp")] <- list(NULL)

imputacion_knn_test<-function(train_imputed, test){
  train_imputed["dataset"] <- 'train'
  test["dataset"] <- 'test'
  dataset_knn = rbind(train_imputed, test) 
  dataset_knn_imputed <- kNN(dataset_knn, variable=c("Temp9am","Temp3pm"))
  dataset_knn_imputed <- kNN(dataset_knn, variable=c("MaxTemp","MinTemp"))
  dataset_knn_imputed <- kNN(dataset_knn, variable=c("Humidity3pm","Humidity9am"))
  dataset_knn_imputed <- kNN(dataset_knn, variable=c("Pressure3pm","Pressure9am"))
  dataset_knn_imputed <- kNN(dataset_knn, variable=c("Humidity9am","Rainfall"))
  train_imputed = subset(dataset_knn_imputed, dataset == 'train')
  test_imputed = subset(dataset_knn_imputed, dataset == 'test')
  test_imputed[c("Temp9am_imp","Temp3pm_imp" ,"MaxTemp_imp","MinTemp_imp", "Humidity9am_imp","Rainfall_imp", "Humidity3pm_imp", "Pressure3pm_imp","Pressure9am_imp","dataset")] <- list(NULL)
  return (test_imputed) }

test_imputed = imputacion_knn_test(train_imputed, test)


```


```{r imputacion4}
#Comprobaciones:
par(mfrow=c(1,2))
plot(density(train$Humidity9am,na.rm = T),col=2,main="Humidity9am")
lines(density(train_imputed$Humidity9am),col=3)
plot(density(train$Rainfall,na.rm = T),col=2,main="Rainfall")
lines(density(train_imputed$Rainfall),col=3)

# Checkea numero de NA
(cols_withNa <- apply(train_imputed, 2, function(x) sum(is.na(x))))
```

Ahora que ya hemos logrado imputar la variable de Rainfall la utilizaremos para conseguir los datos faltantes de raintoday:
```{r imputacion9}
train_imputed$RainToday[which(is.na(train_imputed$RainToday))] <- ifelse(train_imputed$Rainfall == 0, "No", "Yes")
test_imputed$RainToday[which(is.na(test_imputed$RainToday))] <- ifelse(test_imputed$Rainfall == 0, "No", "Yes")



train_imputed$RainToday <- ifelse(train_imputed$RainToday == "Yes", 1, 0)
train_imputed$RainToday = as.numeric(train_imputed$RainToday)

train_imputed$RainTomorrow <- ifelse(train_imputed$RainTomorrow  == "Yes", 1, 0)
train_imputed$RainTomorrow  = as.numeric(train_imputed$RainTomorrow )

test_imputed$RainToday <- ifelse(test_imputed$RainToday == "Yes", 1, 0)
test_imputed$RainToday = as.numeric(test_imputed$RainToday)

test_imputed$RainTomorrow <- ifelse(test_imputed$RainTomorrow  == "Yes", 1, 0)
test_imputed$RainTomorrow  = as.numeric(test_imputed$RainTomorrow )
```

Variables Cloud3pm & Cloud9am:
Para estas variable sutilizamos la librería mice con el metodo de la imputación múltiple y comprobamos que no varía la densidad de los valores.

```{r imputacion Clouds2}
par(mfrow=c(1,1))
train_imputed0 <- mice(train_imputed[,c('Cloud3pm','Cloud9am')], seed=2018, print = F, m = 30)
train_imputed1 <- mice::complete(train_imputed0)
test_imputed0 <- mice(test_imputed[,c('Cloud3pm','Cloud9am')], seed=2018, print = F, m = 30)
test_imputed1 <- mice::complete(test_imputed0)
xyplot(train_imputed0, Cloud3pm ~Cloud9am)

par(mfrow=c(1,2))
plot(density(train$Cloud3pm,na.rm = T),col=2,main="Cloud3pm")
lines(density(train_imputed1$Cloud3pm),col=3)
plot(density(train$Cloud9am,na.rm = T),col=2,main="Cloud9am")
lines(density(train_imputed1$Cloud9am),col=3)

train_imputed$Cloud3pm <- train_imputed1$Cloud3pm
train_imputed$Cloud9am <- train_imputed1$Cloud9am
test_imputed$Cloud3pm <- test_imputed1$Cloud3pm
test_imputed$Cloud9am <- test_imputed1$Cloud9am
```


Variable Evaporation

En esta varible utilizaremos la media de cada estación y con esto sustituiremos los valores faltantes.
```{r Evaporation5}
summer <- filter(train, Season == "summer")
evaporationMeanSummer <- mean(summer$Evaporation,na.rm = TRUE)
winter <- filter(train, Season == "winter")
evaporationMeanWinter <- mean(winter$Evaporation,na.rm = TRUE)
spring <- filter(train, Season == "spring")
evaporationMeanSpring <- mean(spring$Evaporation,na.rm = TRUE)
fall <- filter(train, Season == "fall")
evaporationMeanFall <- mean(fall$Evaporation,na.rm = TRUE)

evaporationMeanSummer
evaporationMeanSpring
evaporationMeanFall
evaporationMeanWinter
```

Aquí podemos observar como la variable de evaporación varia bastante en función de la época del año, en este caso por orden tenemos Verano, Primavera, Otoño e Invierno de mayor a menor, como en el resto de datos de esta variable sólo utiliza un decimal haremos lo mismo para nuestras imputaciones.

```{r Evaporation2}

evaporationMeanSummer <- round(evaporationMeanSummer,1)
evaporationMeanSpring <- round(evaporationMeanSpring,1)
evaporationMeanFall <- round(evaporationMeanFall,1)
evaporationMeanWinter <- round(evaporationMeanWinter,1)

evaporationMeanSummer
evaporationMeanSpring
evaporationMeanFall
evaporationMeanWinter

```
```{r Evaporation3}
train_imputed$Evaporation[which(is.na(train_imputed$Evaporation))] <- ifelse(train_imputed$Season == "summer", evaporationMeanSummer,
                                                                      ifelse(train_imputed$Season == "winter", evaporationMeanWinter,
                                                                      ifelse(train_imputed$Season == "spring", evaporationMeanSpring,
                                                                      ifelse(train_imputed$Season == "fall", evaporationMeanFall,
                                                                      0))))
test_imputed$Evaporation[which(is.na(test_imputed$Evaporation))] <- ifelse(test_imputed$Season == "summer", evaporationMeanSummer,
                                                                      ifelse(test_imputed$Season == "winter", evaporationMeanWinter,
                                                                      ifelse(test_imputed$Season == "spring", evaporationMeanSpring,
                                                                      ifelse(test_imputed$Season == "fall", evaporationMeanFall,
                                                                      0))))
```

Variable Sunshine

En esta variable también utilizaremos la media de cada estación y con esto sustituiremos los valores faltantes.
```{r Sunshine}
SunshineMeanSummer <- mean(summer$Sunshine,na.rm = TRUE)
SunshineMeanWinter <- mean(winter$Sunshine,na.rm = TRUE)
SunshineMeanSpring <- mean(spring$Sunshine,na.rm = TRUE)
SunshineMeanFall <- mean(fall$Sunshine,na.rm = TRUE)

SunshineMeanSummer
SunshineMeanSpring
SunshineMeanFall
SunshineMeanWinter
```

Aquí podemos observar como la variable de Sunshine varía bastante en función de la época del año, en este caso por orden tenemos Verano, Primavera, Otoño e Invierno de mayor a menor, como en el resto de datos de esta variable solo utiliza un decimal haremos lo mismo para nuestras imputaciones.

```{r Sunshine2}

SunshineMeanSummer <- round(SunshineMeanSummer,1)
SunshineMeanSpring <- round(SunshineMeanSpring,1)
SunshineMeanFall <- round(SunshineMeanFall,1)
SunshineMeanWinter <- round(SunshineMeanWinter,1)

SunshineMeanSummer
SunshineMeanSpring
SunshineMeanFall
SunshineMeanWinter

```
```{r Sunshine3}
train_imputed$Sunshine[which(is.na(train_imputed$Sunshine))] <- ifelse(train_imputed$Season == "summer", SunshineMeanSummer,
                                                                      ifelse(train_imputed$Season == "winter", SunshineMeanWinter,
                                                                      ifelse(train_imputed$Season == "spring", SunshineMeanSpring,
                                                                      ifelse(train_imputed$Season == "fall", SunshineMeanFall,
                                                                      0))))

test_imputed$Sunshine[which(is.na(test_imputed$Sunshine))] <- ifelse(test_imputed$Season == "summer", SunshineMeanSummer,
                                                                      ifelse(test_imputed$Season == "winter", SunshineMeanWinter,
                                                                      ifelse(test_imputed$Season == "spring", SunshineMeanSpring,
                                                                      ifelse(test_imputed$Season == "fall", SunshineMeanFall,
                                                                      0))))
```


Variables WindDir & WindSpeed:
Para imputar los datos faltantes en la dirección del viento y en la velocidad utilizaremos la velocidad media que hemos obtenido antes en función de la dirección que tenía el aire a esa misma hora, así nos aseguramos de dar un valor mas acorde a la realidad con los datos de los que disponemos.

Para ello, primero tenemos que hacer un estudio de las variables y sus datos faltantes.
```{r imputacion faltantes windir y winspeed}
trainSelect <- train %>% select(WindDir9am, WindDir3pm, WindSpeed9am,WindSpeed3pm)
gg_miss_upset(trainSelect)
```

Con esta información podemos concluir que los datos que mas faltan son los de la mañana y destacando los datos de la dirección a las 9 de la mañana. Teniendo en cuenta que en el caso de WindDir3pm, WindSpeed9am, WindSpeed3pm, la mayoría de datos NA corresponden con valores faltantes en los demas valores no seremos capaces de imputar dichos valores con estos datos.

```{r imputacion dirspeed}
test <- train %>%
  group_by(WindDir9am) %>%
  summarize(avg_WindSpeed9am = mean(WindSpeed9am))
test
```

Para poder completar todos los valores vamos a imputar datos en la velocidad del viento. Para ello haremos uso del mice con el que gracias a los valores de la presion a la misma hora imputaremos los valores faltantes.

```{r imputacion Clouds}
par(mfrow=c(1,1))
train_imputed0 <- mice(train_imputed[,c('Pressure9am','WindSpeed9am')], seed=2018, print = F, m = 30)
train_imputed1 <- mice::complete(train_imputed0)
test_imputed0 <- mice(test_imputed[,c('Pressure9am','WindSpeed9am')], seed=2018, print = F, m = 30)
test_imputed1 <- mice::complete(test_imputed0)
xyplot(train_imputed0, Pressure9am ~WindSpeed9am)

par(mfrow=c(1,1))
train_imputed2 <- mice(train_imputed[,c('Pressure3pm','WindSpeed3pm')], seed=2018, print = F, m = 30)
train_imputed3 <- mice::complete(train_imputed2)
test_imputed2 <- mice(test_imputed[,c('Pressure3pm','WindSpeed3pm')], seed=2018, print = F, m = 30)
test_imputed3 <- mice::complete(test_imputed2)
xyplot(train_imputed2, Pressure3pm ~WindSpeed3pm)

par(mfrow=c(1,2))
plot(density(train$WindSpeed9am,na.rm = T),col=2,main="WindSpeed9am")
lines(density(train_imputed1$WindSpeed9am),col=3)
plot(density(train$WindSpeed3pm,na.rm = T),col=2,main="WindSpeed3pm")
lines(density(train_imputed3$WindSpeed3pm),col=3)


train_imputed$WindSpeed9am <- train_imputed1$WindSpeed9am
train_imputed$WindSpeed3pm <- train_imputed3$WindSpeed3pm
test_imputed$WindSpeed9am <- test_imputed1$WindSpeed9am
test_imputed$WindSpeed3pm <- test_imputed3$WindSpeed3pm
```


```{r imputacion WindGustSpeed}

a <- data.frame(WindSpeed9am= train_imputed$WindSpeed9am, WindSpeed3pm= train_imputed$WindSpeed3pm)
train_imputed$WindGustSpeed[which(is.na(train_imputed$WindGustSpeed))] <- rowMeans(a, na.rm=TRUE)

b <- data.frame(WindSpeed9am= test_imputed$WindSpeed9am, WindSpeed3pm= test_imputed$WindSpeed3pm)
test_imputed$WindGustSpeed[which(is.na(train_imputed$WindGustSpeed))] <- rowMeans(b, na.rm=TRUE)

```


Transformaciones de variables cualitativas
```{r Eliminar imputaciones }
train_imputed[c("Temp9am_imp","Temp3pm_imp" ,"Pressure9am_imp","Pressure3pm_imp","MaxTemp_imp","MinTemp_imp", "Humidity9am_imp","Humidity3pm_imp","Rainfall_imp")] <- list(NULL)
test_imputed[c("Temp9am_imp","Temp3pm_imp" ,"Pressure9am_imp","Pressure3pm_imp","MaxTemp_imp","MinTemp_imp", "Humidity9am_imp","Humidity3pm_imp","Rainfall_imp")] <- list(NULL)
```

Transformaciones de variables cuantitativas

La única que no parece seguir una distribución normal es la variable RainFall. Analizamos cual es la mejor transformación que podemos aplicar.

```{r cualitativas }
p1 <- train_imputed %>% select(Rainfall, Season) %>%
  na.omit() %>%
  ggplot(aes(x=Rainfall, colour=Season)) +
  geom_density()

aux <- filter(train_imputed,train_imputed$Rainfall>0)
p2 <- aux %>% mutate(inv_Rainfall = 1/ (Rainfall + 1)) %>%
  select(Season, inv_Rainfall) %>%
  na.omit() %>%
  ggplot(aes(x=inv_Rainfall, colour=Season)) +
  geom_density()

p3 <- train_imputed %>% mutate(log10_Rainfall = log10(Rainfall + 1)) %>%
  select(Season, log10_Rainfall) %>%
  na.omit() %>%
  ggplot(aes(x=log10_Rainfall, colour=Season)) +
  geom_density()

grid.arrange(p1, p2, p3, nrow = 1)

aux %>% select(Rainfall) %>%
  na.omit() %>%
  symbox(~ Rainfall, data = .)

```

```{r crear variables transformadas}

train_imputed$Rainfall_Inv <- 1/ (train_imputed$Rainfall + 1)
test_imputed$Rainfall_Inv <- 1/ (test_imputed$Rainfall + 1)
```

Con esta información podemos concluir que para transformarla lo mejor que podemos hacer es utilizar la inversa y sumarle 1 para poder realizar bien la transformación.

Comprobamos algunas variables que sigan distribución normal.

```{r Transformaciones}
#Resto de variables: siguen distribución normal
qqnorm(train_imputed$MinTemp, ylab="MinTemp")
qqline(train_imputed$MinTemp, col="red")

qqnorm(train_imputed$MaxTemp, ylab="MaxTemp")
qqline(train_imputed$MaxTemp, col="red")

qqnorm(train_imputed$Pressure9am, ylab="Pressure9am")
qqline(train_imputed$Pressure9am, col="red")
```

Resumen de valores nulos

```{r check na}
# check NA
train_imputed %>%
  summarise_each(list(~ sum(is.na(.)) / length(.) * 100)) %>%
  t()
```

El resto de nulos los eliminamos por ser un pequeño porcentaje.

## Modelo 1: selección con Lasso sobre el dataset original.

### Estandarización:

Aplicamos la estandarización con las medias y varianzas de train.
```{r estandarizacion}
#Estandarización

numeric_vars <- c("MinTemp","MaxTemp", "Rainfall", "Evaporation", "Sunshine", "WindGustSpeed", 
                  "WindSpeed9am", "WindSpeed3pm", "Humidity9am", "Humidity3pm","Pressure9am" ,
                  "Pressure3pm" , "Temp9am", "Temp3pm", "Rainfall_Inv")

preprocessParams <- preProcess(train_imputed[numeric_vars], method=c("center", "scale"))
train_imputed[numeric_vars] <- predict(preprocessParams, train_imputed[numeric_vars])

#Aplicamos la estandarización con las medias y varianzas de train
test_imputed[numeric_vars] <- predict(preprocessParams, test_imputed[numeric_vars])
```

Creación variables dummies para `Location`, `Season`, `WindGustDir` y borrado de las originales.

```{r variables dummies}
train_imputed <- dummy_cols(train_imputed, select_columns = c("Location", 'Season', 'WindGustDir', 'WindDir9am', 'WindDir3pm'))
test_imputed <- dummy_cols(test_imputed, select_columns = c("Location", 'Season', 'WindGustDir','WindDir9am', 'WindDir3pm'))

train_imputed$Location <- NULL
train_imputed$Season <- NULL
train_imputed$Date <- NULL
train_imputed$WindGustDir <- NULL
train_imputed$RISK_MM <- NULL



test_imputed$Location <- NULL
test_imputed$Season <- NULL
test_imputed$Date <- NULL
test_imputed$WindGustDir <- NULL
test_imputed$WindDir3pm_NA <- NULL
test_imputed$WindDir9am_NA <- NULL
test_imputed$RISK_MM <- NULL
```

### Selección de variables usando Lasso

El modelo utilizado es una regresión logística, realizamos la selección de variables mediante Lasso. Para ello, primero seleccionamos el lambda óptimo y con éste seleccionamos las variables.

```{r variables lasso}
train_imputed_sinNA = na.omit(train_imputed)
x_train = train_imputed_sinNA[, !names(train_imputed_sinNA) %in% c("RainTomorrow")] 

y_train = train_imputed_sinNA$RainTomorrow

test_imputed_sinNA = na.omit(test_imputed)
x_test = test_imputed_sinNA[, !names(test_imputed_sinNA) %in% c("RainTomorrow")] 
y_test = test_imputed_sinNA$RainTomorrow

x = model.matrix(RainTomorrow~ ., train_imputed_sinNA)[,-1]

lambda_seq <- 10^seq(2, -2, by = -.1)
cv.out <- cv.glmnet(x, y_train, alpha = 1, lambda = lambda_seq)

plot(cv.out)
# identifying best lamda
best_lam <- cv.out$lambda.min
lasso_best <- glmnet(x, y_train, alpha = 1, lambda = best_lam)

c<-coef(lasso_best,s=best_lam,exact=TRUE)
inds<-which(c!=0)
variables<-row.names(c)[inds]

```

Variables seleccionados por Lasso

```{r variables seleccionadas por Lasso}
variables
```

### Modelo usando las variables Lasso

```{r modelo1}
new_train = train_imputed_sinNA %>% select("Sunshine","WindGustSpeed", "WindDir9am_N", "WindDir9am_NNE", "WindDir9am_S",  "WindDir3pm_NNE", "Humidity3pm", "Pressure3pm", "Cloud3pm", "RainToday", "Location_Adelaide", "Location_Sydney", "Season_summer", "WindGustDir_ENE", "WindGustDir_NNW", "WindDir9am_N", "WindDir9am_NNE", "WindDir9am_S", "WindDir3pm_NNE", "RainTomorrow") 
  
new_test = test_imputed_sinNA %>% select("Sunshine","WindGustSpeed", "WindDir9am_N", "WindDir9am_NNE", "WindDir9am_S", "WindDir3pm_NNE", "Humidity3pm", "Pressure3pm", "Cloud3pm", "RainToday", "Location_Adelaide", "Location_Sydney", "Season_summer", "WindGustDir_ENE", "WindGustDir_NNW","WindDir9am_N", "WindDir9am_NNE", "WindDir9am_S", "WindDir3pm_NNE", "RainTomorrow")

#Modelo
#Entrenamiento
glm_model_train = glm(RainTomorrow~ ., data=new_train, family= binomial)

#Test
glm_test = predict(glm_model_train, newdata = new_test, type = "response")
```

Resumen del modelo

```{r evaluación modelo1}
#Evaluación modelo
#Summary
summary(glm_model_train)
#Tabla de ganancia
logistic_gains_table <- blr_gains_table(glm_model_train, data = new_train)
```

Vemos que las variables más significativas son los rayos de sol, la velocidad del viento, la humedad, la presión, si ha llovido hoy y si es la ciudad Adelaide, dónde llueve mucho más respecto el resto de ciudades en invierno.

 Curva ROC del modelo
 
```{r roc modelo1}
#Curva ROC
blr_roc_curve(logistic_gains_table)
```

Matriz de confusión

```{r confusion modelo1}
#Matriz de confusión
umbral_dec = 0.46
glm_test <- ifelse(glm_test >= umbral_dec, 1, 0)
glm_test <- factor(glm_test, levels = c(0,1))
tabla_conf <- table(glm_test, new_test$RainTomorrow)
caret::confusionMatrix(tabla_conf, positive = '1')
```


Observando la matriz de confusión se puede ver que el modelo no obtiene buenos resultados pues el número de falsos positivos es muy alto y casi igual al de verdaderos positivos. Por lo que el modelo predice bien cuando no llueve pero no acaba de predecir bien cuando sí va a llover.

Probamos otros modelos para ver si el resultado mejora.

## Modelo 2: selección con Lasso sobre el dataset con interacción de variables.

Como hay muchas variables que están muy relacionadas entre ellas probamos a combinarlas para introducirlas al modelo y que de esta manera no se pierda información.

Para este nuevo modelo usaremos las nuevas variables AvgTemp, Temp, Pressure, Humidity creadas de las medias de las variables a las 9am y a las 3pm. 

```{r estandarizacion new var}
#Estandarización
numeric_vars <- c("MinTemp","MaxTemp", "Rainfall", "Evaporation", "Sunshine", "WindGustSpeed", 
                  "WindSpeed9am", "WindSpeed3pm", "Humidity9am", "Humidity3pm","Pressure9am",
                  "Pressure3pm", "Temp9am", "Temp3pm", "Rainfall_Inv", "AvgTemp", "Temp", "Pressure", "Humidity", "WindSpeed" )

preprocessParams <- preProcess(train_imputed[numeric_vars], method=c("center", "scale"))
train_imputed[numeric_vars] <- predict(preprocessParams, train_imputed[numeric_vars])

#Aplicamos la estandarización con las medias y varianzas de train
test_imputed[numeric_vars] <- predict(preprocessParams, test_imputed[numeric_vars])
```

```{r eleminar variables combinatorias}


train_imputed$WindSpeed9am <- NULL
train_imputed$WindSpeed3pm <- NULL
train_imputed$Humidity9am <- NULL
train_imputed$Humidity3pm <- NULL
train_imputed$MinTemp <- NULL
train_imputed$MaxTemp <- NULL
train_imputed$Pressure9am <- NULL
train_imputed$Pressure3pm <- NULL
train_imputed$Temp9am <- NULL
train_imputed$Temp3pm <- NULL


test_imputed$WindSpeed9am <- NULL
test_imputed$WindSpeed3pm <- NULL
test_imputed$Humidity9am <- NULL
test_imputed$Humidity3pm <- NULL
test_imputed$MinTemp <- NULL
test_imputed$MaxTemp <- NULL
test_imputed$Pressure9am <- NULL
test_imputed$Pressure3pm <- NULL
test_imputed$Temp9am <- NULL
test_imputed$Temp3pm <- NULL
```

### Selección de variables usando Lasso
```{r variables lasso new var}
train_imputed_sinNA = na.omit(train_imputed)
x_train = train_imputed_sinNA[, !names(train_imputed_sinNA) %in% c("RainTomorrow")] 

y_train = train_imputed_sinNA$RainTomorrow

test_imputed_sinNA = na.omit(test_imputed)
x_test = test_imputed_sinNA[, !names(test_imputed_sinNA) %in% c("RainTomorrow")] 
y_test = test_imputed_sinNA$RainTomorrow

dim(test_imputed_sinNA)
dim(train_imputed_sinNA)


#Primero vemos Lasso
x = model.matrix(RainTomorrow~ ., train_imputed_sinNA)[,-1]

lambda_seq <- 10^seq(2, -2, by = -.1)
cv.out <- cv.glmnet(x, y_train, alpha = 1, lambda = lambda_seq)

plot(cv.out)
# identifying best lamda
best_lam <- cv.out$lambda.min
lasso_best <- glmnet(x, y_train, alpha = 1, lambda = best_lam)

c<-coef(lasso_best,s=best_lam,exact=TRUE)
inds<-which(c!=0)
variables<-row.names(c)[inds]
variables


new_train = train_imputed_sinNA %>% select("AvgTemp", "Temp", "Pressure", "Humidity", "WindSpeed", "RainTomorrow") 
  

new_test = test_imputed_sinNA %>% select("AvgTemp", "Temp", "Pressure", "Humidity", "WindSpeed", "RainTomorrow")




#Modelo
#Entrenamiento
glm_model_train = glm(RainTomorrow~ ., data=new_train, family= binomial)

#Test
glm_test = predict(glm_model_train, newdata = new_test, type = "response")

#Evaluación modelo

#Summary
summary(glm_model_train)
#Tabla de ganancia
logistic_gains_table <- blr_gains_table(glm_model_train, data = new_train)
#Curva ROC
blr_roc_curve(logistic_gains_table)
#Matriz de confusión

umbral_dec = 0.46
glm_test <- ifelse(glm_test >= umbral_dec, 1, 0)
glm_test <- factor(glm_test, levels = c(0,1))
tabla_conf <- table(glm_test, new_test$RainTomorrow)
caret::confusionMatrix(tabla_conf, positive = '1')
```

Vemos que utilizando la combinación de las variables no mejora el modelo. El número de falsos positivos es mayor que el de verdaderos positivos. El modelo continua prediciendo bien cuando no va a llover pero su predicción cuando llueve no es exacta.

Los próximos pasos serían realizar un modelo para cada una de las ciudades estudiadas o para cada estación.




